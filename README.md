# Docker_Container


Краткое руководство по Докер
=============================

Докер - прога для упаковки, доставки и сборки программ, которые запакованы в контейнер. Контейнер - это оболочка с прогой внутри, которая запускается по единому механизму. Контейнеры могут содержать программы, написанные на разных языках, которые будут объединены в Образ, и они будут запускаться контейнерами через единый интерфейс (контейнер с разными прогами запускается по 1 сценарию).
Контейнер - работающее приложение, которое создано на основе Образа.

Для контейнера Образ является системой только для чтения, контейнер никак не может внести изменения в Образ. Можно остановить контейнер, удалить его и на основе Образа создать новый контейнер.

Контейнер - рабоющее приложение, которое создается на основе Образа.

Образ - это слоенный пирог. Например, берем УБунту и ставим на нее базу данный, получится “пирог” из 2-х слоев: убунта и ДБ (например MySQL). Могу взять убунту, питон и мое приложение, получится 3 слоя.
Образы находятся локально, докер реджистри. Но можно сделать его удаленным.
Есть удаленный реестр Образов - Докерхаб. Мы можем создать свой образ, запушить его на Докерхаб и потом юзать его на продакшн проектах.

docker images #проверяем образы
docker ps -a #проверяем контейнеры

Будет пусто, т.к. мы не создавали пока ничего


====================
Создаем докер образ

docker build -t hello-world . # hello-worl это тег образа, -t это команда, которая создает этот тег, точка в конце показывает путь к дерриктории, откуда мы будем все собирать, т.е. в данном случае собираем из той дирректории, в которой мы сейчас находимся в терминале. Если это запустить, то выдаст ошибку, т.к. мы не объяснили, что мы хотим сделать, какой именно образ и на каком языке написан наш скрипт.

Пример из видео, был создан файл app.py
В файле простой скрипт:
print("hello world")

#создаем Dockerfile через терминал
touch Dockerfile
В самом файле указываем, какой язык будем использовать и что туда упаковывать:

FROM python: 3.6 

RUN mkdir -p /usr/src/app #RUN определят, что нужно выполнить команду, которая иде за ним, в данном случае мы создаем дирректорию командой mkdir по этому адресу /usr/src/app/

WORKDIR /usr/src/app/ #WORKDIR определяет, что мы переходим в данный каталог и будем там работать

COPY . /usr/src/app/ #COPY принимает два аргуманта, откуда копируем и куда, в данном случае копируем из текущей дирректории, где мы находимся в терминале и вставляем в дирректорию по адресу /usr/src/app/

CMD ["python", "app.py"] #CMD - команда, которая говорит, что Докеру нужно делать, в данном случае нужно выполнить команду python app.py

====================
Есть еще аналог CMD - это ENTRYPOINT. CMD запускается в оболочке, шеле, а ENTRYPOINT без шела
====================
Запускаем снова команду:
docker build -t hello-world .

Запустится сборка Образа

=====================
! Каждая команда в Докерфайле создаст новый слой, и у нас получится пирог с множеством слоем

=====================
Если запустить команду docker images  то увидим разные Образы, включая наш образ hello-world, образ python и т.д.

=====================
Теперь запускаем образ командой:
docker run hello-world #в команде docker run указываем обязательно название образа, в нашем случае это hello-world

Запустится наш контейнер из образа hello-world и сработает скрипт, который выведет в консоль hello world
Контейнер работает, пока работает приложение. Так как наш скрипт сработал, и остановился, то контейнер тоже перестанет работать.

Если ввести команду docker ps (#проверяем контейнеры), то будет пусто, т.к. скрипт уже не работает и контейнер тоже остановился. Но он не исчез, он есть, просто не активен. Чтобы увидет все контейнеры, активные и неактивные, нужно запустить команду:
docker ps -a

! мы увидем, что самый последний столбец NAME будет с каким-то непонятным именем, если мы при создании контейнера не указали ему имя, то Докер сам присвоит ему его.
Чтобы задать имя контейнеру, нужно прописать доп команды:
docker run --name hello hello-world #--name присвоит имя к контейнеру - hello

Запускаем команду:
docker ps -a

Увидим уже 2 контейнера, прошлый и текущий с имененм hello

Чтобы удалить ненужный контейнер, нужно ввести команду 
docker rm hello # можем передать как имя контейнера, так и айди

Чтобы увидеть только айди контейнеров, всех, которые у нас есть, вводим команду:
docker ps -a -q #флаг q выведет только айдишники контейнеров

Чтобы удалить все контейнеры, вводим такую команду:
docker rm $(docker ps -qa)

====================
Работа с вечным циклом

Если скрипт работает вечно, то мы можем его запустить в фоне, чтобы не забивать инфой вывод консоли, для этого пропысываем такую команду при запуске котейнера с флагом -d (удобно, когда хотим дальше работать с консолью):

docker run --name hello -d hello-world

Чтобы остановить вечный контейнер, нужно:
docker stop hello

Контейнер остановится, но не удалится

====
Чтобы удалить контейнер после остановки скрипта или после того, как я его сам остановлю, нужно при создании контейнера добавить флаг --rm:

docker run --name hello -d --rm hello-world

====================
Работа с ВЕБ прилами, проброс портов из контейнера на комп
Контейнер работает изолированно, он не будет принимать и отправлят наружу ничего, если ему это не указать. Чтобы, например, запустить из контейнера веб прилу на порт 8080, нужно в Докерфайле указать:
EXPOSE 8080 #декларирует, что мы можем использовать внешний порт 8080, т.е. это не запуска просто декларация

Собираем Образ командой docker run --name web hello-world

Запускаем контейнер командой:

docker run --rm --name web -p 8080:8080 web-hello # -p 8080:8080 этот флаг указывает первый порт в докер контейнере и второй порт на нашем компе


=====================
Переменная окружения (например нужно указать правильную временную зону в контейнере, чтобы небыло разницы между временем компа и контейнера)

В докерфайле нужно прописать:
ENV TZ Erope/Kyiv # установим таймзону Киева

Так же можно переменную прописать не в Докерфайле. Это нужно, если будут меняться какие то папки или урлы, в зависимости от каки-то ньансов работы программы. Это можно сделать из консоли:
docker run --rm --name web -p 8080:8080 -e TZ=Europe/Kyiv web-hello # -e флаг переменной окружения, мы задали таймзону Киева прямо при запуске контейнера.

=====================
Как прикрутить внешние данные к контейнеру. 
Так как контейнер это оболочка, которая работает независимо, то любые изменения в самом контейнере, если он работает, не будут видны на сайте.

Есть 2 способа
======
Монтируем локальные папки, но сейчас он используется реже
Первый способ, добавляем флаг -v в строке при запуске самого контейнера:

docker run --rm --name web -p 8080:8080 -e TZ=Europe/Kyiv -v /Users/vynchuk/Desktop/python_Container/t06:/usr/src/app/resorces web-hello #этот путь /usr/src/app/ мы берем из докер файла COPY . /usr/src/, т.е. куда мы копируем, а первый путь, это путь к папке, где у нас находится база или файл с джейсоном, resorces это та папка, в которой у нас в нашей проге хранится база

======
Второй способ, это Доке волюм

Чтобы посмотреть, какие волюмы у нас есть, щапускаем команду:
docker volume ls

Мы увим, что там будеит пусто, т.к. мы не создавали никакие волюмы.

Чтобы создать Волюм, запускаем команду:

docker volume create web

Теперь если запустим docker volume ls, увидим пустой волюм с именем web
Запускаем в терминале сборку контейнера с такой командой:


docker run --rm --name web -p 8080:8080 -e TZ=Europe/Kyiv -v web:/usr/src/app/resorces web-hello #тут вместо относительного пути мы указываем имя Волюма, в нашем случае это web

!!!! Это актуально для БАЗ ДАННЫХ !!!!

Если мы удалим или остановим контейнер, то с данными в Волюме ничего не произойдет, мы можем их прикрутить к другому контейнеру

=============================
=============================
Работа контейнера с БАЗАМИ ДАННЫХ

=============================

45 - 50 минуты видео

=============================
=============================

Удаляем Образы

docker images # выдаст список образов

docker rmi web-hello # удалит образ с именем web-hello, (имя Образа находится в столбце REPOSITORY)

Удалятся все слои этого Образа

Так же есть образы с именем <none>, эти образы берустя, когда мы создаем Образ с одним и тем же тегом, т.е. новый образ получаем имя, например web-hello, а старый образ получает тег <none>

=======
Как удалить образы с именем <none>
Можно указать не имя, а айди образа, который мы хотим удалить

удаляем все образы:
docker rmi $(docker images -g) # docker images -g выдает список айди всех образов


==============================
==============================
==============================


Каждый микросервис должен иметь свой Докерфайл

ДОКЕР КОМПОУС

распологаем его в корне:
docker-compose.yaml

=======
В этом файле увидим следующее: (ВИДЕО 01:02:42)

version: "3" #версия
volumes: # какие Волюмы мы хотим включить
  mongodb_valume: #это пример из видоса, можем название ставить свое, нужно тогда, когда хотим сохранить данные после стопа или удаления контейнера
services:
	yuotube_statistic: # название сервиса
  		build: StatisticManager/ #указываем папку, где нужно собрать докер файл, т.е. в этой папке код микросервиса где есть свой Докерфайл
  		restart: always # после остановки и нового запуска, докер снова подымет все эти контейнеры
  		environment: #тут указываем все переменные, которые мы хотим передать контейнеру (Переменные окружения)
  			- TZ=Europe/Kyiv
  			- RESPONSE_DELAY=120
  			- LANGUAGE=RU
        - MONGO_DB_ADDR=mongodb # mongodb мы потом пропишем ниже, как название сервиса
  			..... и т.д., то что мы ранее указывали при запуске docker run ...

  	mongodb: # название сервиса, мы его прописывали в Вольюме выше
    	image: mongo:latest
    	volumes:
    		- mongo_volume:/data/db #это пример из видоса, параметр mongo_volume мы прописывали выше, в самом начале докер-компоуса, в строке volumes:
    	restart: always

    web_service: # название сервиса
      build: WebService/ #указываем папку, куда нужно зайти и где нужно запустить Докер файл, который там находится
      restart: always
      port:
        - 8080:8080 # указываем порт внутренний:внешний
      environment:
        - MONGO_DB_ADDR=mongodb
        - TZ=Europe/Kyiv
        и т.д.




docker images -
=======

1.24 установка докера на сервак
